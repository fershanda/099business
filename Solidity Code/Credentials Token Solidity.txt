// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title CredentialToken
 * @dev ERC20-like token that represents a business credential with descriptive metadata.
 *      All metadata is set at deployment and immutable afterwards.
 */

contract CredentialToken {
    // Basic ERC20 state
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;

    // Metadata fields for Credential
    string public tokenType;              // e.g. "Credential"
    string public howToUse;               // e.g. "Holding this Token made Credentials apply..."
    string public paperPage;              // reference page (URL or CID)
    string public description;            // description of credential
    string public issuerResponsibility;   // issuer's duty

    address public issuer;                // contract deployer / issuer

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _initialSupply,
        address _recipient,
        string memory _tokenType,
        string memory _howToUse,
        string memory _paperPage,
        string memory _description,
        string memory _issuerResponsibility
    ) {
        issuer = msg.sender;

        name = _name;
        symbol = _symbol;
        totalSupply = _initialSupply * (10 ** uint256(decimals));

        tokenType = _tokenType;
        howToUse = _howToUse;
        paperPage = _paperPage;
        description = _description;
        issuerResponsibility = _issuerResponsibility;

        // Mint tokens to recipient
        balances[_recipient] = totalSupply;
        emit Transfer(address(0), _recipient, totalSupply);
    }

    // --- ERC20-like functions ---
    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        require(to != address(0), "Invalid address");

        balances[msg.sender] -= amount;
        balances[to] += amount;

        emit Transfer(msg.sender, to, amount);
        return true;
    }
}
